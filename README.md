# CS2433: POPL2
## Mini Assignment 2: Large Code Bases and OOP
### Grandhi Sai Sidhardha
#### CS19BTECH11050
---

This report is based on the [Clang/LLVM](https://github.com/llvm/llvm-project) Code base. LLVM is basically a compiler infrastructure wich is written in C++. It is designed for compile-time, link-time, run-time and idle-time optimization of programs written in arbitrary programming languages.
This report basically discusses about:

- C++ 11 /C++ 14 features used
- Class hierarchy
- OOP design decisions for LLVM
- Design Patterns
- Usage of iterators and their own data structures

in Clang/LLVM Code base.

---

## C++ 11/C++ 14 features used
There are many features used in the Clang/LLVM.

Some of the features wich are adopted/taken from C ++11 include alias templates, alignment specifiers, attributes, decltype(), defaulted functions, deleted functions, generalized initializers, inheriting constructors, lambdas, noexcept, nullptr, override control, range-based for loop, thread_local, thread_local, Unicode string literals and trailing return type.

binary literals, contextual conversions, decltype(auto),  default initializers for aggregates, digit separators, generalized lambda capture, generic lambdas, relaxed constexpr, return type deduction, runtime-sized arrays and variable templates are few of the features of C++ 14 which are used in Clang/LLVM.

[Reference1](https://clang.llvm.org/docs/LanguageExtensions.html)

---

## Class hierarchy

Class hierarchy is the object type classificationdenoting objects as the instantiations of classes, inter-relating the various classes by relationships such as "inherits", "extends", "is an abstraction of", "an interface definition".Each class inherits variables and methods from its superclass, and may add more variables and methods or override existing ones.

There are many classes in Clangand LLVP too. They are sorted as per the charts in the below hyperlinks.
[CLass hierarchy in LLVP](https://llvm.org/doxygen/inherits.html)
[CLass hierarchy in Clang](https://clang.llvm.org/doxygen/inherits.html)

[Reference1](https://en.wikipedia.org/wiki/Class_hierarchy)
[Reference2](https://www.cs.cmu.edu/afs/cs/academic/class/15745-s16/www/lectures/L3-LLVM2.pdf)

---

## OOP design decisions for LLVM
Inheritance is one of the key functions in Object Oriented Programming. It is used to set up relations between the classes. Inheritance for implementation reuse leads to Tight Coupling. Re-usability of code is achieved through composition. The inheritance is widely used in the llvm/clang source code but multiple inheritance is not widely used.

In polymorphism, we discuss about virtual function or virtual method, which is an inheritable and overridable function or method for which dynamic dispatch is facilitated. In Clang/LLVP, any methods are virtual, and some of them are pure virtual.

[Reference1](https://cppdepend.com/blog/?p=92)

---
## Design Patterns

Clang compiler has three phase:

- The front end that parses source code, checking it for errors, and builds a language-specific Abstract Syntax Tree (AST) to represent the input code.
- The optimizer: its goal is to do some optimisaion on the AST generated by the front end.
- The back end : that generate the final code to be executed by the machine, it depends of the target.

The idea behind LLVM is to use LLVM Intermediate Representation (IR) which is designed to host mid-level analyses and transformations that you find in the optimizer section of a compiler. Supporting lightweight runtime optimizations, cross-function/interprocedural optimizations, whole program analysis, and aggressive restructuring transformations are some of the major goals of the Clang design.
One of the major design concepts for Clang is its use of a library-based architecture. The llvm/clang is very well designed.

[Reference1](https://cppdepend.com/blog/?p=92)

---
## Usage of iterators and their own data structures
LLVM provides lots of data structures:
>BitVector, DenseMap, DenseSet, ImmutableList, ImmutableMap, ImmutableSet, IntervalMap, IndexedMap, MapVector, PriorityQueue, SetVector, ScopedHashTable, SmallBitVector, SmallPtrSet, SmallSet, SmallString, SmallVector, SparseBitVector, SparseSet, StringMap, StringRef, StringSet, Triple, TinyPtrVector, PackedVector, FoldingSet, UniqueVector, ValueMap

The iterator works in various ways with each data structure. Some things to be kept in mind while using these iterators are:
> Be careful when modifying an object while iterating over it (iterator invalidation)
- Can cause unexpected behavior; use a separate removal list
> Use preincrement (++i) rather than postincrement (i++) 
- Avoids problems with iterators doing unexpected things
- Likely more performant, especially for complex iterators
>Iterators can overlap with each other
- e.g., InstIterator walks over all instructions in a function, which overlaps withBasicBlock::iterator


[Reference1](https://www.cs.cmu.edu/afs/cs/academic/class/15745-s16/www/lectures/L3-LLVM2.pdf)
[Reference2](https://clang.llvm.org/extra/clang-tidy/checks/modernize-use-auto.html)
[Reference3](https://llvm.org/doxygen/iterator_8h_source.html)

---
Link to the github profile: https://github.com/G-Sidhardha
